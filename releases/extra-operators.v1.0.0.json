{"fields":{"title":"$:/plugins/EvidentlyCube/ExtraOperators","name":"Extra Operators","version":"1.0.0","core-version":">=5.2.2","description":"Adds new filter operators","author":"Maurycy Zarzycki","source":"https://github.com/EvidentlyCube/TW5-FilterOperators","plugin-type":"plugin","list":["readme","license","history"],"dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/EvidentlyCube/ExtraOperators/common.js\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/common.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/common.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nSmart sorting of search results\\n\\n\\\\*/\\n(function(){\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\texports.TEXT_ONLY_REGEXPS = [\\n\\t\\t[/\\\\\\\\define\\\\s+([^(\\\\s]+)\\\\([^\\\\)]*\\\\)(\\\\r?\\\\n(\\\\s|\\\\S)*?\\\\end|.+?(\\\\r?\\\\n|$))/ig, ''], // Macro definitions\\n\\t\\t[/^\\\\s*\\\\\\\\(?:\\\\s|\\\\S)+?($|\\\\n([^\\\\\\\\\\\\r\\\\n]))/ig, '$1'], // Arbitrary pragmas at the start\\n\\t\\t[/\\\\[img[^\\\\]]*\\\\]\\\\]/ig, ''], // Images\\n\\t\\t[/^@@.*?(\\\\r?\\\\n|$)/igm, ''], // Styles\\n\\t\\t[/^\\\\$\\\\$\\\\$.*?(\\\\r?\\\\n|$)/igm, ''], // Typed block\\n\\t\\t[/\\\\{\\\\{\\\\{[^\\\\}]*\\\\}\\\\}\\\\}/ig, ''], // Filter invocations\\n\\t\\t[/\\\\{\\\\{[^\\\\}]*\\\\}\\\\}/ig, ''], // Transclusions\\n\\t\\t[/\\\\[\\\\[([^\\\\]]+(?=\\\\|))?\\\\|?[^\\\\]]+\\\\]\\\\]/ig, '$1'], // Links\\n\\t\\t[/<<[^>]*>>/ig, ''], // Macro invocations\\n\\t\\t[/<\\\\/?[^>]*>/ig, ''], // HTML Tags\\n\\t\\t[/''|`|__|\\\\/\\\\/|^!+\\\\s+|~~/mg, '']\\n\\t];\\n\\n\\texports.SIMPLIFY_REGEXP = /[^a-z0-9_-]/ig;\\n\\n\\texports.getRegexpsForPhrase = function(phrase) {\\n\\t\\tconst escapedPhrase = $tw.utils.escapeRegExp(phrase);\\n\\n\\t\\treturn [\\n\\t\\t\\tnew RegExp(`^${escapedPhrase}\\\\\\\\b`, 'gi'),\\n\\t\\t\\tnew RegExp(`^${escapedPhrase}`, 'gi'),\\n\\t\\t\\tnew RegExp(`\\\\\\\\b${escapedPhrase}\\\\\\\\b`, 'gi'),\\n\\t\\t\\tnew RegExp(`\\\\\\\\b${escapedPhrase}`, 'gi'),\\n\\t\\t\\tnew RegExp(escapedPhrase, 'gi'),\\n\\t\\t];\\n\\t};\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/EvidentlyCube/ExtraOperators/focus-on.js\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/focus-on.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/focus-on.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nExtract part of text focusing on the first occurrence\\n\\n\\\\*/\\n(function (require) {\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\texports['focus-on'] = function (source, operator, opts) {\\n\\t\\tconst operands = operator.operands || [];\\n\\t\\tconst suffixes = (operator.suffixes || []);\\n\\t\\tconst flags = suffixes[0] || [];\\n\\t\\tconst options = {\\n\\t\\t\\tmatch: operands[0] || '',\\n\\t\\t\\tprefixLength: extractInteger(operands[1], 20),\\n\\t\\t\\tfocusLength: extractInteger(operands[2], 128),\\n\\t\\t\\tellipsis: extractString(operands[3], '...'),\\n\\t\\t\\tisRegexp: flags.includes('regexp'),\\n\\t\\t\\tisCaseSensitive: flags.includes('casesensitive'),\\n\\t\\t\\thtmlMode: extractHtmlMode(flags),\\n\\t\\t\\twiki: opts.wiki,\\n\\t\\t\\ttemplate: operator.operands[1] || '<mark>$1</mark>'\\n\\t\\t};\\n\\n\\t\\tconst titles = [];\\n\\n\\t\\tsource(function (tiddler, title) {\\n\\t\\t\\ttitles.push(focusOn(title, options));\\n\\t\\t});\\n\\n\\t\\treturn titles;\\n\\t};\\n\\n\\tfunction focusOn(title, options) {\\n\\t\\tconst matchIndex = getFirstMatchIndex(title, options.match, options);\\n\\t\\tconst startIndex = getStartIndex(title, matchIndex, options);\\n\\t\\tconst endIndex = getEndIndex(title, matchIndex, options);\\n\\n\\t\\treturn (startIndex > 0 ? options.ellipsis : '')\\n\\t\\t\\t+ title.substring(startIndex, endIndex)\\n\\t\\t\\t+ (endIndex < title.length - 1 ? options.ellipsis : '');\\n\\t}\\n\\n\\tfunction getFirstMatchIndex(title, match, options) {\\n\\t\\tif (options.isRegexp) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\treturn Math.max(0, title.search(new RegExp(match, options.isCaseSensitive ? '' : 'i')));\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t// Handle invalid regular expressions\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!options.isCaseSensitive) {\\n\\t\\t\\ttitle = title.toLocaleLowerCase();\\n\\t\\t\\tmatch = match.toLocaleLowerCase();\\n\\t\\t}\\n\\n\\t\\treturn Math.max(0, title.indexOf(match));\\n\\t}\\n\\n\\tfunction getStartIndex(title, matchIndex, options) {\\n\\t\\tconst baseIndex = Math.max(0, matchIndex - options.prefixLength);\\n\\t\\tif (options.htmlMode === 'ignore-html') {\\n\\t\\t\\treturn baseIndex;\\n\\t\\t}\\n\\n\\t\\tconst openTagIndex = title.indexOf('<', baseIndex);\\n\\t\\tconst closeTagIndex = title.indexOf('>', baseIndex);\\n\\t\\tconst openTagPrevIndex = title.lastIndexOf('<', baseIndex);\\n\\t\\tconst closeTagPrevIndex = title.lastIndexOf('>', baseIndex);\\n\\n\\t\\tif (isInsideHtmlTag(openTagPrevIndex, openTagIndex, closeTagPrevIndex, closeTagIndex)) {\\n\\t\\t\\treturn options.htmlMode === 'strip-html'\\n\\t\\t\\t\\t? closeTagIndex + 1\\n\\t\\t\\t\\t: openTagPrevIndex;\\n\\t\\t}\\n\\n\\t\\treturn baseIndex;\\n\\t}\\n\\n\\tfunction getEndIndex(title, matchIndex, options) {\\n\\t\\tconst baseIndex = Math.min(title.length -1, matchIndex + options.focusLength);;\\n\\t\\tif (options.htmlMode === 'ignore-html') {\\n\\t\\t\\treturn baseIndex;\\n\\t\\t}\\n\\n\\t\\tconst openTagIndex = title.indexOf('<', baseIndex);\\n\\t\\tconst closeTagIndex = title.indexOf('>', baseIndex);\\n\\t\\tconst openTagPrevIndex = title.lastIndexOf('<', baseIndex);\\n\\t\\tconst closeTagPrevIndex = title.lastIndexOf('>', baseIndex);\\n\\n\\t\\tif (isInsideHtmlTag(openTagPrevIndex, openTagIndex, closeTagPrevIndex, closeTagIndex)) {\\n\\t\\t\\treturn options.htmlMode === 'strip-html'\\n\\t\\t\\t\\t? openTagPrevIndex\\n\\t\\t\\t\\t: closeTagIndex + 1;\\n\\t\\t}\\n\\n\\t\\treturn baseIndex;\\n\\t}\\n\\n\\tfunction isInsideHtmlTag(leftOpenTagIndex, rightOpenTagIndex, leftCloseTagIndex, rightCloseTagIndex) {\\n\\t\\tif (rightOpenTagIndex !== -1 && rightCloseTagIndex !== -1) {\\n\\t\\t\\tif (rightCloseTagIndex < rightOpenTagIndex && leftOpenTagIndex !== -1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (leftOpenTagIndex !== -1 && leftCloseTagIndex !== -1) {\\n\\t\\t\\tif (leftOpenTagIndex > leftCloseTagIndex && rightCloseTagIndex !== -1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\n\\tfunction extractHtmlMode(flags) {\\n\\t\\tif (flags.includes('ignore-html')) {\\n\\t\\t\\treturn 'ignore-html';\\n\\t\\t} else if (flags.includes('strip-html')) {\\n\\t\\t\\treturn 'strip-html';\\n\\t\\t} else {\\n\\t\\t\\treturn 'expand-html';\\n\\t\\t}\\n\\t}\\n\\n\\tfunction extractInteger(value, defaultValue) {\\n\\t\\tif (value === undefined) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\tconst intValue = parseInt(value);\\n\\t\\tif (Number.isNaN(intValue)) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\treturn Math.max(0, Math.min(9999, intValue));\\n\\t}\\n\\n\\tfunction extractString(value, defaultValue) {\\n\\t\\tif (value === undefined) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\treturn String(value);\\n\\t}\\n})(typeof global !== 'undefined' ? global.testRequire : require);\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/EvidentlyCube/ExtraOperators/history\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/history\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"* ''1.0.0'' -- Added `searchsort` filter operator\"},\"$:/plugins/EvidentlyCube/AutoComplete/icon\":{\"title\":\"$:/plugins/EvidentlyCube/AutoComplete/icon\",\"text\":\"iVBORw0KGgoAAAANSUhEUgAAACMAAAAjCAYAAAAe2bNZAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAELklEQVRYhc2X309bZRjHP+/hnNIC2nXt5hYjrJHR8cOR1CiRBBISk6FGE2JK1JtdmEi4IPPKkOwf2D9g8ErTW27UC4WYGJRVL7xAN2DJ4hjMDRI2VmiRdqenPa8Xb1fa0gIt0PhNTs573vd9nvdznve3kFJK/ifSnyeSySRzc3OkUqmaNe5wOAgGg7hcrl2YZDJJf38/fr8fj8dTsVMpJaZp4nQ6K7Lb3NxkeXmZ2dlZBSSllJFIRIZCIWnbtqxGa2trcmxsrGI727ZlKBSSkUhESimlDpBKpfB4PFiWxfXr14nH4wV/cOXKFVZXV1lYWKClpYWOjg6mpqYA0DSNnp4e7ty5U3FEhRB4PJ7c0MiNGSkluq4zNDSEaZoFRn6/n7a2Nrq6unC73fh8Ptxud86hYRgVg+S3+1w6gNfrZXFxEcuy6O3tPZST5ubmXHp7e5uRkZGKQUzTZHFxEa/XC4DIdh83btxgenr6SH9ZqSzLYnBwkPHxcYQQCgZUuJLJJOl0umYwuq7jcrkQQqhvANu2CYfDTE5OYllWzWAMw2B4eJirV6+iaZqCmZ+fJxwOMzExgcPhqBlMKpVidHSUYDBId3e3golGowQCAdrb28nYkCnaIAwNbLk3vxIZGqQlIEHXINszBAIBotEokDe1AVIZ+Pwn2Cqc2XxwER7G4c/16mE+6YQfl+BZGq69Ad0v7a1TAOOogy/fUfT5EiKbdYTICAHvte6mS6kAxpZwL5oNZ5E8TjDTkMhONpeu4GN5URTAhVOqrBzQftoD88sD2C6xcQfPweYzWN5S3y+/AL4GuJXXdboGH3eWhzlIBWa6Bp8FK3Pwtr+6hg+EsSX8/kh1R76EgOIjmBDwqgce70C8aMDn12n1QLO7CpiMDb89LO+8WIYGC0/gUbx0uRBqXFUMs7IFP9yDgPdwhgBPk3C+ST3ltJGA7+6WL1/ZKgHz8wr8+i1cPgvObO5yDLwueLFoUZbA3afQ4laDdX0HHsSpauqnV2C8GCZjQx0w3AHuepU3tQTtPrhQIszh2/D+RTjtgj/W4JvbykfFyrPJwbT7oO8y/B3dLTzToMK8kdjro/MM3N9Sjybg0+4qQICbkRIwfc3w1bvwNAFpG5ocanYlspu4Uwe3Uy1sx6mR70vAgIL4+pZa9PpeUe+/1hVAmxc+6lBr0UmpAMbQ4Iu3Cit8eOnkGt8XJiPh5j9q995Pr52F+5uwU+Icdq5JzcgjwwA8ScC/B1wqL3khmoSN5N6ypiOczQpg6gSE2g9neNhVtWqYjJ09ABWFXwh4/Tz4Tx0/QFkYiRoLxd0kBLSePlmQHIxhGMRiMeqE5Nqbx72S7K9YLJa7qwkppUwkEgwMDFBfX09jY2PNQHZ2djBNk5mZGRoaGnYvcZZlsbS0VNN7k67rtLa2FkamZq0foP8APw/vuJS94F4AAAAASUVORK5CYII=\",\"type\":\"image/png\"},\"$:/plugins/EvidentlyCube/ExtraOperators/license\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/license\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"This plugin is licensed under the MIT license.\\n\\nCopyright 2023 Maurycy Zarzycki\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\"},\"$:/plugins/EvidentlyCube/ExtraOperators/readme\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/readme\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"[[Github|https://github.com/EvidentlyCube/TW5-AutoComplete]]\\n\\n----\\n\\n! Features\\n\\nA versatile and easy to use auto completion for TiddlyWiki:\\n\\n* Auto complete anything you want:\\n** Tiddler titles\\n** Field values\\n** Any filter result\\n* Define your own triggers\\n** Customize the filter which retrieves the suggestions\\n** Customize template used for inserting the selected suggestion\\n** Customize how the suggestions are displayed in the completion window\\n** Control auto-triggering separately for inputs and text areas\\n* Clear interface for editing the triggers\\n* Manually open auto complete with customizable keyboard shortcut\\n\\n!! Plugin compatibility\\n\\n * Official [[Code Mirror|https://tiddlywiki.com/plugins/tiddlywiki/codemirror/]] plugin\\n * [[Streams|https://saqimtiaz.github.io/streams/]] by saqimtiaz\\n\\n! How to use\\n\\n* After installing head to the Control Panel and open the tab ''Evidently Cube''\\n* Create a new trigger using the button\\n** It will be filled with sensible defaults\\n** Customize the trigger to your heart's content\\n* At any time press <kbd>Ctrl+Space</kbd> right in front of a defined trigger to open the completion window manually\\n** Or use a different keyboard shortcut you defined\"},\"$:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch-mark.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nSmart sorting of search results\\n\\n\\\\*/\\n(function (require) {\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\\n\\n\\texports['susearch-mark'] = function (source, operator, opts) {\\n\\t\\tconst query = operator.operand || '';\\n\\t\\tconst suffixes = (operator.suffixes || []);\\n\\t\\tconst optionFlags = suffixes[0] || [];\\n\\t\\tconst options = {\\n\\t\\t\\tmode: extractMode(optionFlags),\\n\\t\\t\\twiki: opts.wiki,\\n\\t\\t\\ttemplate: operator.operands[1] || '<mark>$1</mark>'\\n\\t\\t};\\n\\n\\t\\tconst fullRegexp = prepareFullRegexp(query);\\n\\t\\tconst titles = [];\\n\\n\\t\\tsource(function (tiddler, title) {\\n\\t\\t\\ttitles.push(mark(title, fullRegexp, options));\\n\\t\\t});\\n\\n\\t\\treturn titles;\\n\\t};\\n\\n\\tfunction mark(title, fullRegexp, options) {\\n\\t\\tswitch (options.mode) {\\n\\t\\t\\tcase 'default':\\n\\t\\t\\t\\treturn doFullRegexpReplace(title, fullRegexp, options.template);\\n\\n\\t\\t\\tcase 'raw-strip':\\n\\t\\t\\t\\treturn doFullRegexpReplace(rawStrip(title), fullRegexp, options.template);\\n\\n\\t\\t\\tcase 'wikify-strip':\\n\\t\\t\\t\\treturn doFullRegexpReplace(\\n\\t\\t\\t\\t\\twikify(title, options.wiki, false).textContent,\\n\\t\\t\\t\\t\\tfullRegexp,\\n\\t\\t\\t\\t\\toptions.template\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\tcase 'wikify-safe':\\n\\t\\t\\t\\treturn wikifySafe(title, fullRegexp, options, false);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction doFullRegexpReplace(title, fullRegexp, template) {\\n\\t\\treturn fullRegexp\\n\\t\\t\\t? title.replace(fullRegexp, template)\\n\\t\\t\\t: title;\\n\\t}\\n\\n\\tfunction prepareFullRegexp(query) {\\n\\t\\tconst sanitizedQuery = query.replace(/\\\\s+/g, ' ').trim().toLowerCase();\\n\\t\\tconst words = sanitizedQuery.split(' ').filter(word => word);\\n\\t\\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\\n\\n\\t\\tif (sanitizedQuery === '') {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tconst regexpPieces = [$tw.utils.escapeRegExp(sanitizedQuery)];\\n\\t\\tregexpPieces.push(...words.map(word => $tw.utils.escapeRegExp(word)));\\n\\t\\tregexpPieces.push(...simplifiedWords.map(word => $tw.utils.escapeRegExp(word)));\\n\\n\\t\\treturn new RegExp('(' + regexpPieces.join(\\\"|\\\").replace(/ /g, '\\\\\\\\s+') + ')', 'gi');\\n\\t}\\n\\n\\tfunction wikify(text, wiki, isInline) {\\n\\t\\tconst parser = wiki.parseText(\\\"text/vnd.tiddlywiki\\\", text, {parseAsInline: isInline });\\n\\t\\tconst container = $tw.fakeDocument.createElement(\\\"div\\\");\\n\\t\\tconst widget = wiki.makeWidget(parser, {\\n\\t\\t\\tdocument: $tw.fakeDocument,\\n\\t\\t\\tparentWidget: $tw.rootWidget\\n\\t\\t});\\n\\t\\twidget.render(container, null);\\n\\n\\t\\treturn container;\\n\\t}\\n\\n\\tfunction rawStrip(field) {\\n\\t\\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field);\\n\\t}\\n\\n\\tfunction extractMode(optionFlags) {\\n\\t\\tswitch (optionFlags.join(',')) {\\n\\t\\t\\tcase 'raw-strip': return 'raw-strip';\\n\\t\\t\\tcase 'wikify-strip': return 'wikify-strip';\\n\\t\\t\\tcase 'wikify-safe': return 'wikify-safe';\\n\\t\\t\\tdefault: return 'default';\\n\\t\\t}\\n\\t}\\n\\n\\tfunction wikifySafe(text, fullRegexp, options, isInline) {\\n\\t\\tconst wikifiedText = wikify(text, options.wiki, isInline).innerHTML;\\n\\t\\tconst tokens = [];\\n\\n\\t\\tconst protectedText = wikifiedText.replace(/<[^>]+>/g, function(token) {\\n\\t\\t\\ttokens.push(token);\\n\\t\\t\\treturn \\\"\\\\u001D\\\";\\n\\t\\t});\\n\\t\\tconst replacedText = doFullRegexpReplace(protectedText, fullRegexp, options.template);\\n\\n\\t\\treturn replacedText.replace(/\\\\u001D/g, function() {\\n\\t\\t\\treturn tokens.shift();\\n\\t\\t});\\n\\t}\\n\\n})(typeof global !== 'undefined' ? global.testRequire : require);\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch-sort.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nSmart sorting of search results\\n\\n\\\\*/\\n(function(require){\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\\n\\n\\texports['susearch-sort'] = function(source, operator) {\\n\\t\\tconst query = operator.operand || '';\\n\\t\\tconst suffixes = (operator.suffixes || []);\\n\\t\\tconst optionFlags = suffixes[1] || [];\\n\\t\\tconst options = {\\n\\t\\t\\tfield: (suffixes[0] || [])[0] || 'title',\\n\\t\\t\\ttextOnly: optionFlags.indexOf('raw-strip') !== -1\\n\\t\\t};\\n\\n\\t\\tconst records = [];\\n\\n\\t\\tsource(function(tiddler, title) {\\n\\t\\t\\trecords.push(tiddler ? tiddler.fields : {title: title});\\n\\t\\t});\\n\\n\\t\\treturn susearchSort(records, query, options).map(record => record.title);\\n\\t};\\n\\n\\tfunction susearchSort(records, query, options) {\\n\\t\\tconst sanitizedQuery = query.replace(/\\\\s+/g, ' ').trim();\\n\\t\\tconst words = sanitizedQuery.split(' ').filter(word => word);\\n\\t\\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\\n\\n\\t\\tif (words.length === 0) {\\n\\t\\t\\treturn textSort(records, options.field);\\n\\n\\t\\t} else if (words.length === 1) {\\n\\t\\t\\treturn sortInternal(records, sanitizedQuery, [], [], options);\\n\\n\\t\\t} else {\\n\\t\\t\\treturn sortInternal(records, sanitizedQuery, words, simplifiedWords, options);\\n\\t\\t}\\n\\t};\\n\\n\\tfunction textSort(records, sortField) {\\n\\t\\treturn records.concat().sort(function (left, right) {\\n\\t\\t\\tif (!left[sortField] && !right[sortField]) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t} else if (!left[sortField]) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t} else if (!right[sortField]) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn left[sortField].localeCompare(right[sortField], { numeric: true, sensitivity: \\\"base\\\" });\\n\\t\\t});\\n\\t}\\n\\n\\tfunction sortInternal(records, query, words, simplifiedWords, options) {\\n\\t\\tconst fullQueryRegexps = [query, common.getRegexpsForPhrase(query)];\\n\\t\\tconst wordsRegexps = words.map(word => [word, common.getRegexpsForPhrase(word)]);\\n\\t\\tconst simplifiedWordsRegexps = simplifiedWords.map(word => [word, common.getRegexpsForPhrase(word)]);\\n\\t\\tconst scores = records.map(record => getScore(record, options, fullQueryRegexps, wordsRegexps, simplifiedWordsRegexps));\\n\\n\\t\\tscores.sort(recordsSortCallback);\\n\\n\\t\\treturn scores.map(x => x[4]);\\n\\t}\\n\\n\\tfunction recordsSortCallback(left, right) {\\n\\t\\tif (left[0][0] !== right[0][0]) {\\n\\t\\t\\treturn right[0][0] - left[0][0];\\n\\n\\t\\t} else if (left[0][1] !== right[0][1]) {\\n\\t\\t\\treturn right[0][1] - left[0][1];\\n\\n\\t\\t} else if (left[0][2] !== right[0][2]) {\\n\\t\\t\\treturn left[0][2] - right[0][2];\\n\\n\\t\\t} else if (left[1].length !== right[1].length) {\\n\\t\\t\\treturn right[1].length - left[1].length;\\n\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = 0; i < left[1].length; i++) {\\n\\t\\t\\t\\tif (left[1][i][0] !== right[1][i][0]) {\\n\\t\\t\\t\\t\\treturn right[1][i][0] - left[1][i][0];\\n\\n\\t\\t\\t\\t} else if (left[1][i][1] !== right[1][i][1]) {\\n\\t\\t\\t\\t\\treturn right[1][i][1] - left[1][i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (left[2].length !== right[2].length) {\\n\\t\\t\\treturn right[2].length - left[2].length;\\n\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = 0; i < left[2].length; i++) {\\n\\t\\t\\t\\tif (left[2][i][0] !== right[2][i][0]) {\\n\\t\\t\\t\\t\\treturn right[2][i][0] - left[2][i][0];\\n\\n\\t\\t\\t\\t} else if (left[2][i][1] !== right[2][i][1]) {\\n\\t\\t\\t\\t\\treturn right[2][i][1] - left[2][i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let i = 0; i < left[3].length; i++) {\\n\\t\\t\\tconst score = left[3][i].localeCompare(right[3][i], { numeric: true, sensitivity: \\\"base\\\" });\\n\\t\\t\\tif (score !== 0) {\\n\\t\\t\\t\\treturn score;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfunction getScore(record, options, fullQueryRegexp, wordsRegexps, simplifiedWordsRegexps) {\\n\\t\\tconst rawField = record[options.field] || '';\\n\\t\\tconst field = prepareField(rawField, options);\\n\\t\\tconst simplifiedField = field.replace(common.SIMPLIFY_REGEXP, '');\\n\\t\\tconst fullQueryScore = getRegexpScore(field, fullQueryRegexp[0], fullQueryRegexp[1]);\\n\\t\\tconst wordScores = wordsRegexps\\n\\t\\t\\t.map(r => getRegexpScore(field, r[0], r[1]))\\n\\t\\t\\t.filter(x => x)\\n\\t\\t\\t.sort(wordSortCallback);\\n\\t\\tconst simplifiedWordScores = simplifiedWordsRegexps\\n\\t\\t\\t.map(r => getRegexpScore(simplifiedField, r[0], r[1]))\\n\\t\\t\\t.filter(x => x)\\n\\t\\t\\t.sort(wordSortCallback);\\n\\n\\t\\treturn [\\n\\t\\t\\tfullQueryScore || [-1, -1, Number.MAX_SAFE_INTEGER], // Full query score match type\\n\\t\\t\\twordScores, // Word scores\\n\\t\\t\\tsimplifiedWordScores, // Word scores\\n\\t\\t\\t[field.toLowerCase(), field, rawField.toLowerCase(), rawField], // Field\\n\\t\\t\\trecord // Record\\n\\t\\t];\\n\\t}\\n\\n\\tfunction wordSortCallback(left, right) {\\n\\t\\tif (left[0] !== right[0]) {\\n\\t\\t\\treturn right[0] - left[0];\\n\\n\\t\\t} else if (left[1] !== right[1]) {\\n\\t\\t\\treturn right[1] - left[1];\\n\\n\\t\\t} else {\\n\\t\\t\\treturn left[2] - right[2];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getRegexpScore(text, query, regexps) {\\n\\t\\tfor (let i = 0; i < regexps.length; i++) {\\n\\t\\t\\tconst matches = regexpCount(text, regexps[i]);\\n\\t\\t\\tif (matches === 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn [\\n\\t\\t\\t\\tregexps.length - i,\\n\\t\\t\\t\\tmatches * 10000\\n\\t\\t\\t\\t+ regexpCount(text, regexps[regexps.length - 1]),\\n\\t\\t\\t\\ttext.toLowerCase().indexOf(query.toLowerCase())\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t}\\n\\n\\tfunction regexpCount(text, regexp) {\\n\\t\\tconst matches = text.match(regexp);\\n\\n\\t\\treturn matches ? matches.length : 0;\\n\\t}\\n\\n\\tfunction prepareField(field, options) {\\n\\t\\tif (options.textOnly) {\\n\\t\\t\\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field).trim();\\n\\t\\t}\\n\\t\\treturn field;\\n\\t}\\n\\n})(typeof global !== 'undefined' ? global.testRequire : require);\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"},\"$:/plugins/EvidentlyCube/ExtraOperators/susearch.js\":{\"title\":\"$:/plugins/EvidentlyCube/ExtraOperators/susearch.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/EvidentlyCube/ExtraOperators/susearch.js\\ntype: application/javascript\\nmodule-type: filteroperator\\n\\nSmart search\\n\\n\\\\*/\\n(function(require){\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global $tw: false */\\n\\t\\\"use strict\\\";\\n\\n\\tconst common = require('$:/plugins/EvidentlyCube/ExtraOperators/common.js');\\n\\n\\texports.susearch = function(source, operator) {\\n\\t\\tconst query = operator.operand || '';\\n\\t\\tconst suffixes = (operator.suffixes || []);\\n\\t\\tconst optionFlags = suffixes[1] || [];\\n\\t\\tconst options = {\\n\\t\\t\\tfield: (suffixes[0] || [])[0] || 'title',\\n\\t\\t\\ttextOnly: optionFlags.indexOf('raw-strip') !== -1\\n\\t\\t};\\n\\n\\t\\tconst sanitizedQuery = query.replace(/\\\\s+/g, ' ').trim().toLowerCase();\\n\\t\\tconst words = sanitizedQuery.split(' ').filter(word => word);\\n\\t\\tconst simplifiedWords = sanitizedQuery.replace(common.SIMPLIFY_REGEXP, '').split(' ').filter(word => word);\\n\\n\\t\\tconst titles = [];\\n\\n\\t\\tsource(function(tiddler, title) {\\n\\t\\t\\tif (susearch(tiddler ? tiddler.fields : {title: title}, options, sanitizedQuery, words, simplifiedWords)) {\\n\\t\\t\\t\\ttitles.push(title);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn titles;\\n\\t};\\n\\n\\tfunction susearch(record, options, sanitizedQuery, words, simplifiedWords) {\\n\\t\\tconst field = prepareField(record[options.field] || '', options).toLowerCase();\\n\\t\\tconst simplifiedField = field.replace(common.SIMPLIFY_REGEXP, '');\\n\\n\\t\\tif (field.indexOf(sanitizedQuery) !== -1) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (const word of words) {\\n\\t\\t\\tif (field.indexOf(word) !== -1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (const word of simplifiedWords) {\\n\\t\\t\\tif (simplifiedField.indexOf(word) !== -1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction prepareField(field, options) {\\n\\t\\tif (options.textOnly) {\\n\\t\\t\\treturn common.TEXT_ONLY_REGEXPS.reduce((field, [regexp, replace]) => field.replace(regexp, replace), field);\\n\\t\\t}\\n\\t\\treturn field;\\n\\t}\\n\\n})(typeof global !== 'undefined' ? global.testRequire : require);\\n\",\"type\":\"application/javascript\",\"module-type\":\"filteroperator\"}}}"},"cache":{}}